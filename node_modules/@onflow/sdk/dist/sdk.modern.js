import{config as e}from"@onflow/config";import{invariant as t}from"@onflow/util-invariant";import{Transaction as n,SendTransactionRequest as a,AccessAPI as r,GetTransactionRequest as o,ExecuteScriptAtBlockIDRequest as s,ExecuteScriptAtBlockHeightRequest as c,ExecuteScriptAtLatestBlockRequest as i,GetAccountAtBlockHeightRequest as u,GetAccountAtLatestBlockRequest as l,GetEventsForHeightRangeRequest as d,GetEventsForBlockIDsRequest as g,GetBlockByIDRequest as p,GetBlockByHeightRequest as f,GetLatestBlockRequest as m,PingRequest as h}from"@onflow/protobuf";import{sansPrefix as y,withPrefix as k}from"@onflow/util-address";import{grpc as I}from"@improbable-eng/grpc-web";import{NodeHttpTransport as w}from"@improbable-eng/grpc-web-node-http-transport";import{encode as b}from"@onflow/rlp";import{template as S}from"@onflow/util-template";export{template as cadence,template as cdc}from"@onflow/util-template";function v(){return(v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const B='{\n  "tag":"UNKNOWN",\n  "assigns":{},\n  "status":"OK",\n  "reason":null,\n  "accounts":{},\n  "params":{},\n  "arguments":{},\n  "message": {\n    "cadence":null,\n    "refBlock":null,\n    "computLimit":null,\n    "proposer":null,\n    "payer":null,\n    "authorizations":[],\n    "params":[],\n    "arguments":[]\n  },\n  "proposer":null,\n  "authorizations":[],\n  "payer":null,\n  "events": {\n    "eventType":null,\n    "start":null,\n    "end":null,\n    "blockIds":[]\n  },\n  "transaction": {\n    "id":null\n  },\n  "block": {\n    "id":null,\n    "height":null,\n    "isSealed":null\n  },\n  "account": {\n    "addr":null\n  }\n}',A=new Set(Object.keys(JSON.parse(B))),x=()=>JSON.parse(B),T=e=>null==e,N="abcdefghijklmnopqrstuvwxyz0123456789".split(""),E=()=>N[~~(Math.random()*N.length)],L=()=>Array.from({length:10},E).join(""),_=e=>(e.status="OK",e),O=(e,t)=>(e.status="BAD",e.reason=t,e),U=e=>t=>(t.tag=e,_(t)),C=(e,t)=>n=>(n.accounts[t]=JSON.parse('{\n  "kind":"ACCOUNT",\n  "tempId":null,\n  "addr":null,\n  "keyId":null,\n  "sequenceNum":null,\n  "signature":null,\n  "signingFunction":null,\n  "resolve":null,\n  "role": {\n    "proposer":false,\n    "authorizer":false,\n    "payer":false,\n    "param":false\n  }\n}'),n.accounts[t].tempId=t,n.accounts[t].addr=e.addr,n.accounts[t].keyId=e.keyId,n.accounts[t].sequenceNum=e.sequenceNum,n.accounts[t].signature=e.signature,n.accounts[t].signingFunction=e.signingFunction,n.accounts[t].resolve=e.resolve,n.accounts[t].role=v({},n.accounts[t].role,e.role),_(n)),R=e=>t=>{let n=L();return t.message.params.push(n),t.params[n]=JSON.parse('{\n  "kind":"PARAM",\n  "tempId":null,\n  "key":null,\n  "value":null,\n  "asParam":null,\n  "xform":null,\n  "resolve": null\n}'),t.params[n].tempId=n,t.params[n].key=e.key,t.params[n].value=e.value,t.params[n].asParam=e.asParam,t.params[n].xform=e.xform,t.params[n].resolve=e.resolve,_(t)},D=e=>t=>{let n=L();return t.message.arguments.push(n),t.arguments[n]=JSON.parse('{\n  "kind":"ARGUMENT",\n  "tempId":null,\n  "value":null,\n  "asArgument":null,\n  "xform":null,\n  "resolve": null\n}'),t.arguments[n].tempId=n,t.arguments[n].value=e.value,t.arguments[n].asArgument=e.asArgument,t.arguments[n].xform=e.xform,t.arguments[n].resolve=e.resolve,_(t)},G=U("SCRIPT"),K=U("TRANSACTION"),P=U("GET_TRANSACTION_STATUS"),j=U("GET_TRANSACTION"),H=U("GET_ACCOUNT"),z=U("GET_EVENTS"),F=U("GET_LATEST_BLOCK"),q=U("GET_BLOCK_BY_ID"),J=U("GET_BLOCK_BY_HEIGHT"),$=U("PING"),W=U("GET_BLOCK"),Y=U("GET_BLOCK_HEADER"),M=e=>t=>t.tag===e,V=M("UNKNOWN"),X=M("SCRIPT"),Q=M("TRANSACTION"),Z=M("GET_TRANSACTION_STATUS"),ee=M("GET_TRANSACTION"),te=M("GET_ACCOUNT"),ne=M("GET_EVENTS"),ae=M("GET_LATEST_BLOCK"),re=M("GET_BLOCK_BY_ID"),oe=M("GET_BLOCK_BY_HEIGHT"),se=M("PING"),ce=M("GET_BLOCK"),ie=M("GET_BLOCK_HEADER"),ue=e=>"OK"===e.status,le=e=>"BAD"===e.status,de=e=>e.reason,ge=async(e,t=[])=>{try{if(e=(e=>{for(let t of Object.keys(e))if(!A.has(t))throw new Error(`"${t}" is an invalid root level Interaction property.`);return e})(await e),le(e))throw new Error("Interaction Error: "+e.reason);if(!t.length)return e;const[n,...a]=t,r=await n;if("function"==typeof r)return ge(r(e),a);if(T(r)||!r)return ge(e,a);if((e=>{if("object"!=typeof e||T(e)||(e=>"number"==typeof e)(e))return!1;for(let t of A)if(!e.hasOwnProperty(t))return!1;return!0})(r))return ge(r,a);throw new Error("Invalid Interaction Composition")}catch(e){throw e}},pe=(...e)=>{const[t,n]=e;return Array.isArray(t)&&null==n?e=>pe(e,t):ge(t,n)},fe=e=>e,me=(e,t,n)=>null==e.assigns[t]?n:e.assigns[t],he=(e,t)=>n=>(n.assigns[e]=t,_(n)),ye=(e,t=fe)=>n=>(n.assigns[e]=t(n.assigns[e],n),_(n)),ke=e=>t=>(delete t.assigns[e],_(t));function Ie(e=[]){return pe(x(),e)}const we=()=>JSON.parse('{"tag": 0, "transaction":null, "transactionId":null, "encodedData":null, "events": null, "account": null}');async function be(e,t,n){return new Promise((a,r)=>{I.unary(t,{request:n,host:e,onEnd:({status:e,statusMessage:t,message:n})=>{e===I.Code.OK?a(n):r(new Error(t))}})})}I.setDefaultTransport(w());const Se=e=>Buffer.from(e,"hex"),ve=e=>Buffer.from(e.padStart(16,0),"hex"),Be=e=>Buffer.from(e).toString("hex"),Ae=e=>Buffer.from(JSON.stringify(e),"utf8"),xe=e=>Buffer.from(e).toString("hex"),Te=e=>Buffer.from(e).toString("hex"),Ne=e=>Buffer.from(e).toString("hex"),Ee=e=>Buffer.from(e).toString("hex"),Le=e=>Buffer.from(e).toString("hex"),_e=e=>Buffer.from(e).toString("hex"),Oe=async(t,I={})=>{switch(I.node=I.node||await e().get("accessNode.api"),t=await t,!0){case Q(t):return async function(e,t={}){e=await e;const o=new n;o.setScript((e=>Buffer.from(e,"utf8"))(e.message.cadence)),o.setGasLimit(e.message.computeLimit),o.setReferenceBlockId(e.message.refBlock?Se(e.message.refBlock):null),o.setPayer(ve(y(e.accounts[e.payer].addr))),e.message.arguments.forEach(t=>o.addArguments((e=>Buffer.from(JSON.stringify(e),"utf8"))(e.arguments[t].asArgument))),e.authorizations.map(t=>e.accounts[t].addr).reduce((e,t)=>e.find(e=>e===t)?e:[...e,t],[]).forEach(e=>o.addAuthorizers(ve(y(e))));const s=new n.ProposalKey;s.setAddress(ve(y(e.accounts[e.proposer].addr))),s.setKeyId(e.accounts[e.proposer].keyId),s.setSequenceNumber(e.accounts[e.proposer].sequenceNum),o.setProposalKey(s);for(let t of Object.values(e.accounts))try{if(!t.role.payer&&null!=t.signature){const e=new n.Signature;e.setAddress(ve(y(t.addr))),e.setKeyId(t.keyId),e.setSignature(Se(t.signature)),o.addPayloadSignatures(e)}}catch(n){throw console.error("Trouble applying payload signature",{acct:t,ix:e}),n}for(let t of Object.values(e.accounts))try{if(t.role.payer&&null!=t.signature){const e=new n.Signature;e.setAddress(ve(y(t.addr))),e.setKeyId(t.keyId),e.setSignature(Se(t.signature)),o.addEnvelopeSignatures(e)}}catch(n){throw console.error("Trouble applying envelope signature",{acct:t,ix:e}),n}const c=new a;c.setTransaction(o);var i=Date.now();const u=await be(t.node,r.SendTransaction,c);var l=Date.now();let d=we();var g;return d.tag=e.tag,d.transactionId=(g=u.getId_asU8(),Buffer.from(g).toString("hex")),"undefined"!=typeof window&&window.dispatchEvent(new CustomEvent("FLOW::TX",{detail:{txId:d.transactionId,delta:l-i}})),d}(t,I);case Z(t):return async function(e,t={}){e=await e;const n=new o;n.setId(Buffer.from(e.transaction.id,"hex"));const a=await be(t.node,r.GetTransactionResult,n);let s=a.getEventsList(),c=we();return c.tag=e.tag,c.transactionStatus={status:a.getStatus(),statusCode:a.getStatusCode(),errorMessage:a.getErrorMessage(),events:s.map(e=>{return{type:e.getType(),transactionId:(t=e.getTransactionId_asU8(),Buffer.from(t).toString("hex")),transactionIndex:e.getTransactionIndex(),eventIndex:e.getEventIndex(),payload:JSON.parse(Buffer.from(e.getPayload_asU8()).toString("utf8"))};var t})},c}(t,I);case ee(t):return async function(e,t={}){e=await e;const n=new o;n.setId(Buffer.from(e.transaction.id,"hex"));const a=await be(t.node,r.GetTransaction,n);let s=we();s.tag=e.tag;const c=e=>({address:Be(e.getAddress_asU8()),keyId:e.getKeyId(),signature:Be(e.getSignature_asU8())});let i=a.getTransaction();var u;return s.transaction={script:Buffer.from(i.getScript_asU8()).toString("utf8"),args:i.getArgumentsList().map(e=>JSON.parse(Buffer.from(e).toString("utf8"))),referenceBlockId:Be(i.getReferenceBlockId_asU8()),gasLimit:i.getGasLimit(),proposalKey:(u=i.getProposalKey(),{address:Be(u.getAddress_asU8()),keyId:u.getKeyId(),sequenceNumber:u.getSequenceNumber()}),payer:Be(i.getPayer_asU8()),authorizers:i.getAuthorizersList().map(Be),payloadSignatures:i.getPayloadSignaturesList().map(c),envelopeSignatures:i.getEnvelopeSignaturesList().map(c)},s}(t,I);case X(t):return async function(e,t={}){let n,a;if((e=await e).block.id){n=new s,n.setBlockId(Buffer.from(e.block.id,"hex"));const o=Buffer.from(e.message.cadence,"utf8");e.message.arguments.forEach(t=>n.addArguments(Ae(e.arguments[t].asArgument))),n.setScript(o),a=await be(t.node,r.ExecuteScriptAtBlockID,n)}else if(e.block.height){n=new c,n.setBlockHeight(Number(e.block.height));const o=Buffer.from(e.message.cadence,"utf8");e.message.arguments.forEach(t=>n.addArguments(Ae(e.arguments[t].asArgument))),n.setScript(o),a=await be(t.node,r.ExecuteScriptAtBlockHeight,n)}else{n=new i;const o=Buffer.from(e.message.cadence,"utf8");e.message.arguments.forEach(t=>n.addArguments(Ae(e.arguments[t].asArgument))),n.setScript(o),a=await be(t.node,r.ExecuteScriptAtLatestBlock,n)}let o=we();return o.tag=e.tag,o.encodedData=JSON.parse(Buffer.from(a.getValue_asU8()).toString("utf8")),o}(t,I);case te(t):return async function(e,t={}){const n=(e=await e).block.height?new u:new l;var a;e.block.height&&n.setHeight(Number(e.block.height)),n.setAddress((a=y(e.account.addr),Buffer.from(a.padStart(16,0),"hex")));const o=await be(t.node,e.block.height?r.GetAccountAtBlockHeight:r.GetAccountAtLatestBlock,n);let s=we();s.tag=e.tag;const c=o.getAccount();let i;const d=(i=c.getContractsMap())?i.getEntryList().reduce((e,t)=>v({},e,{[t[0]]:new TextDecoder("utf-8").decode(t[1]||new UInt8Array)}),{}):{};return s.account={address:k(xe(c.getAddress_asU8())),balance:c.getBalance(),code:new TextDecoder("utf-8").decode(c.getCode_asU8()||new UInt8Array),contracts:d,keys:c.getKeysList().map(e=>({index:e.getIndex(),publicKey:xe(e.getPublicKey_asU8()),signAlgo:e.getSignAlgo(),hashAlgo:e.getHashAlgo(),weight:e.getWeight(),sequenceNumber:e.getSequenceNumber(),revoked:e.getRevoked()}))},s}(t,I);case ne(t):return async function(e,t={}){let n;const a=(e=await e).events.start?new d:new g;a.setType(e.events.eventType),e.events.start?(a.setStartHeight(Number(e.events.start)),a.setEndHeight(Number(e.events.end)),n=await be(t.node,r.GetEventsForHeightRange,a)):(e.events.blockIds.forEach(e=>a.addBlockIds(Buffer.from(e,"hex"))),n=await be(t.node,r.GetEventsForBlockIDs,a));let o=we();o.tag=e.tag;const s=n.getResultsList();return o.events=s.reduce((e,t)=>{const n=Te(t.getBlockId_asU8()),a=t.getBlockHeight(),r=t.getBlockTimestamp().toDate().toISOString();return t.getEventsList().forEach(t=>{e.push({blockId:n,blockHeight:a,blockTimestamp:r,type:t.getType(),transactionId:Te(t.getTransactionId_asU8()),transactionIndex:t.getTransactionIndex(),eventIndex:t.getEventIndex(),payload:JSON.parse(Buffer.from(t.getPayload_asU8()).toString("utf8"))})}),e},[]),o}(t,I);case ae(t):return async function(e,t={}){e=await e;const n=new m;e.latestBlock&&e.latestBlock.isSealed&&(n.setIsSealed(e.latestBlock.isSealed),console.error("\n          %c@onflow/send Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the interaction object is deprecated and will no longer be recognized in future releases of @onflow/send.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/send/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;")),e.block&&e.block.isSealed&&n.setIsSealed(e.block.isSealed);const a=(await be(t.node,r.GetLatestBlock,n)).getBlock(),o=a.getCollectionGuaranteesList(),s=a.getBlockSealsList(),c=a.getSignaturesList(),i=we();return i.tag=e.tag,i.block={id:Ee(a.getId_asU8()),parentId:Ee(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:o.map(e=>({collectionId:Ee(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:s.map(e=>({blockId:Ee(e.getBlockId_asU8()),executionReceiptId:Ee(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:c},i}(t,I);case ce(t):return async function(e,t={}){let n,a;(e=await e).block.id?(n=new p,n.setId(Buffer.from(e.block.id,"hex")),a=await be(t.node,r.GetBlockByID,n)):e.block.height?(n=new f,n.setHeight(Number(e.block.height)),a=await be(t.node,r.GetBlockByHeight,n)):(n=new m,a=await be(t.node,r.GetLatestBlock,n));const o=a.getBlock(),s=o.getCollectionGuaranteesList(),c=o.getBlockSealsList(),i=o.getSignaturesList(),u=we();return u.tag=e.tag,u.block={id:Ne(o.getId_asU8()),parentId:Ne(o.getParentId_asU8()),height:o.getHeight(),timestamp:o.getTimestamp(),collectionGuarantees:s.map(e=>({collectionId:Ne(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:c.map(e=>({blockId:Ne(e.getBlockId_asU8()),executionReceiptId:Ne(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:i},u}(t,I);case re(t):return async function(e,t={}){e=await e;const n=new p;n.setId(Buffer.from(e.block.id,"hex"));const a=(await be(t.node,r.GetBlockByID,n)).getBlock(),o=a.getCollectionGuaranteesList(),s=a.getBlockSealsList(),c=a.getSignaturesList(),i=we();return i.tag=e.tag,i.block={id:Le(a.getId_asU8()),parentId:Le(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:o.map(e=>({collectionId:Le(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:s.map(e=>({blockId:Le(e.getBlockId_asU8()),executionReceiptId:Le(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:c},i}(t,I);case oe(t):return async function(e,t={}){e=await e;const n=new f;n.setHeight(Number(e.block.height));const a=(await be(t.node,r.GetBlockByHeight,n)).getBlock(),o=a.getCollectionGuaranteesList(),s=a.getBlockSealsList(),c=a.getSignaturesList(),i=we();return i.tag=e.tag,i.block={id:_e(a.getId_asU8()),parentId:_e(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:o.map(e=>({collectionId:_e(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:s.map(e=>({blockId:_e(e.getBlockId_asU8()),executionReceiptId:_e(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:c},i}(t,I);case se(t):return async function(e,t={}){e=await e;const n=new h;await be(t.node,r.Ping,n);let a=we();return a.tag=e.tag,a}(t,I);default:return t}};function Ue(e=null){return pe([W,t=>(t.block.isSealed=e,_(t))])}function Ce(e){return pe([H,t=>(t.account.addr=y(e),_(t))])}const Re=async(e,t,n)=>{try{return Number(e)}catch(e){throw new Error("Decode Number Error : "+n.join("."))}},De=async e=>e,Ge=async(e,t,n)=>{const a=await e.fields.reduce(async(e,a)=>((e=await e)[a.name]=await je(a.value,t,[...n,a.name]),e),Promise.resolve({})),r=e.id&&Pe(t,e.id);return r?await r(a):a},Ke={UInt:Re,Int:Re,UInt8:Re,Int8:Re,UInt16:Re,Int16:Re,UInt32:Re,Int32:Re,UInt64:Re,Int64:Re,UInt128:Re,Int128:Re,UInt256:Re,Int256:Re,Word8:Re,Word16:Re,Word32:Re,Word64:Re,UFix64:De,Fix64:De,String:De,Character:De,Bool:De,Address:De,Void:async()=>null,Optional:async(e,t,n)=>e?await je(e,t,n):null,Reference:async e=>({address:e.address,type:e.type}),Array:async(e,t,n)=>await Promise.all(e.map(e=>new Promise(async a=>a(await je(e,t,[...n,e.type]))))),Dictionary:async(e,t,n)=>await e.reduce(async(e,a)=>((e=await e)[await je(a.key,t,[...n,a.key])]=await je(a.value,t,[...n,a.key]),e),Promise.resolve({})),Event:Ge,Resource:Ge,Struct:Ge},Pe=(e,t)=>{const n=Object.keys(e).find(e=>/^\/.*\/$/.test(e)?new RegExp(e.substring(1,e.length-1)).test(t):e===t);return t&&n&&e[n]},je=async(e,t,n)=>{let a=Pe(t,e.type);if(!a)throw new Error(`Undefined Decoder Error: ${e.type}@${n.join(".")}`);return await a(e.value,t,n)},He=async(e,t={},n=[])=>{let a=v({},Ke,t);return await je(e,a,n)},ze=async(e,t={})=>{let n=v({},Ke,t);return e.encodedData?await He(e.encodedData,n):e.transactionStatus?v({},e.transactionStatus,{events:await Promise.all(e.transactionStatus.events.map(async function(e){return{type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await He(e.payload,n)}}))}):e.transaction?e.transaction:e.events?await Promise.all(e.events.map(async function(e){return{blockId:e.blockId,blockHeight:e.blockHeight,blockTimestamp:e.blockTimestamp,type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await He(e.payload,n)}})):e.account?e.account:e.block?e.block:e.blockHeader?e.blockHeader:e.latestBlock?(console.error("\n          %c@onflow/decode Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the response object is deprecated and will no longer be recognized in future releases of @onflow/decode.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;"),e.latestBlock):e.transactionId?e.transactionId:null};function Fe(e){return async t=>Q(t)?(t.message.refBlock||(t.message.refBlock=await async function(e){var t;return t=await pe(x(),[Ue()]),t=await Oe(t,e),(t=await ze(t)).id}(e)),_(t)):_(t)}const qe=e=>"function"==typeof e,Je=e=>"string"==typeof e;async function $e(n){if(Q(n)||X(n)){var a=me(n,"ix.cadence");t(qe(a)||Je(a),"Cadence needs to be a function or a string."),qe(a)&&(a=await a({})),t(Je(a),"Cadence needs to be a string at this point."),n.message.cadence=await e().where(/^0x/).then(e=>Object.entries(e).reduce((e,[t,n])=>e.replace(t,n),a))}return n}const We=e=>"function"==typeof e;function Ye(e){return t(null!=typeof e.xform,"No type specified for argument: "+e.value),We(e.xform)?e.xform(e.value):We(e.xform.asArgument)?e.xform.asArgument(e.value):void t(!1,"Invalid Argument",e)}async function Me(e){if(Q(e)||X(e))for(let[t,n]of Object.entries(e.arguments))e.arguments[t].asArgument=Ye(n);return e}function Ve(e,t){try{return{f_type:"PreSignable",f_vsn:"1.0.0",roles:e.role,cadence:t.message.cadence,args:t.message.arguments.map(e=>t.arguments[e].asArgument),data:{},interaction:t}}catch(e){throw console.error("buildPreSignable",e),e}}async function Xe(e,n,a,r=3){t(r,"Account Resolve Recursion Limit Exceeded",{ix:e,accounts:n});let o=[];for(let t of n){var s=a||t;"function"==typeof t.resolve&&(t=await t.resolve(t,Ve(t,e))),Array.isArray(t)?await Xe(e,t,s,r-1):(e.accounts[t.tempId]=e.accounts[t.tempId]||t,e.accounts[t.tempId].role.proposer=e.accounts[t.tempId].role.proposer||t.role.proposer,e.accounts[t.tempId].role.payer=e.accounts[t.tempId].role.payer||t.role.payer,e.accounts[t.tempId].role.authorizer=e.accounts[t.tempId].role.authorizer||t.role.authorizer,e.accounts[t.tempId].role.proposer&&e.proposer===s.tempId&&(e.proposer=t.tempId),e.accounts[t.tempId].role.payer&&e.payer===s.tempId&&(e.payer=t.tempId),e.accounts[t.tempId].role.authorizer&&(a?o=[...o,t.tempId]:e.authorizations=e.authorizations.map(e=>e===s.tempId?t.tempId:e))),s.tempId!=t.tempId&&delete e.accounts[s.tempId]}a&&(e.authorizations=e.authorizations.map(e=>e===a.tempId?o:e).reduce((e,t)=>Array.isArray(t)?[...e,...t]:[...e,t],[]))}async function Qe(e){if(Q(e))try{await Xe(e,Object.values(e.accounts)),await Xe(e,Object.values(e.accounts))}catch(e){throw console.error("=== SAD PANDA ===\n\n",e,"\n\n=== SAD PANDA ==="),e}return e}const Ze=(e,t)=>Buffer.from(e.padStart(2*t,0),"hex"),et=e=>Ze(e,8),tt=e=>Buffer.from(JSON.stringify(e),"utf8"),nt=e=>Buffer.from(e,"utf8"),at=e=>b(e).toString("hex"),rt=e=>{return ct(e),[nt(e.script),e.arguments.map(tt),(t=e.refBlock,Ze(t,32)),e.gasLimit,et(e.proposalKey.address),e.proposalKey.keyId,e.proposalKey.sequenceNum,et(e.payer),e.authorizers.map(et)];var t},ot=e=>{const t=st(e);return e.payloadSigs.map(e=>({signerIndex:t.get(e.address),keyId:e.keyId,sig:e.sig})).sort((e,t)=>e.signerIndex>t.signerIndex?1:e.signerIndex<t.signerIndex?-1:e.keyId>t.keyId?1:e.keyId<t.keyId?-1:void 0).map(e=>{return[e.signerIndex,e.keyId,(t=e.sig,Buffer.from(t,"hex"))];var t})},st=e=>{const t=new Map;let n=0;const a=e=>{t.has(e)||(t.set(e,n),n++)};return a(e.proposalKey.address),a(e.payer),e.authorizers.forEach(a),t},ct=e=>{gt.forEach(t=>ht(e,t)),pt.forEach(t=>ht(e.proposalKey,t,"proposalKey"))},it=e=>"number"==typeof e,ut=e=>"string"==typeof e,lt=e=>null!==e&&"object"==typeof e,dt=e=>lt(e)&&e instanceof Array,gt=[{name:"script",check:ut},{name:"arguments",check:dt},{name:"refBlock",check:ut,defaultVal:"0"},{name:"gasLimit",check:it},{name:"proposalKey",check:lt},{name:"payer",check:ut},{name:"authorizers",check:dt}],pt=[{name:"address",check:ut},{name:"keyId",check:it},{name:"sequenceNum",check:it}],ft=[{name:"payloadSigs",check:dt}],mt=[{name:"address",check:ut},{name:"keyId",check:it},{name:"sig",check:ut}],ht=(e,t,n,a)=>{const{name:r,check:o,defaultVal:s}=t;if(null==e[r]&&null!=s&&(e[r]=s),null==e[r])throw kt(r,n,a);if(!o(e[r]))throw It(r,n,a)},yt=(e,t,n)=>t?null==n?`${t}.${e}`:`${t}.${n}.${e}`:e,kt=(e,t,n)=>new Error("Missing field "+yt(e,t,n)),It=(e,t,n)=>new Error("Invalid field "+yt(e,t,n));async function wt(e){if(Q(e))try{let n=function(e){let t=new Set(e.authorizations);return t.add(e.proposer),t.delete(e.payer),Array.from(t)}(e);const a=(t=St(e),at(rt(t)));await Promise.all(n.map(bt(e,a)));let r=function(e){let t=new Set([e.payer]);return Array.from(t)}(e);const o=(e=>at((e=>((e=>{ft.forEach(t=>ht(e,t)),e.payloadSigs.forEach((e,t)=>{mt.forEach(n=>ht(e,n,"payloadSigs",t))})})(e),[rt(e),ot(e)]))(e)))(v({},St(e),{payloadSigs:n.map(t=>({address:e.accounts[t].addr,keyId:e.accounts[t].keyId,sig:e.accounts[t].signature}))}));await Promise.all(r.map(bt(e,o)))}catch(t){throw console.error("Signatures",t,{ix:e}),t}var t;return e}function bt(e,t){return async function(n){const a=e.accounts[n];if(null!=a.signature)return;const{signature:r}=await a.signingFunction(function(e,t,n){try{return{f_type:"Signable",f_vsn:"1.0.0",message:t,addr:y(e.addr),keyId:e.keyId,roles:e.role,cadence:n.message.cadence,args:n.message.arguments.map(e=>n.arguments[e].asArgument),data:{},interaction:n}}catch(e){throw console.error("buildSignable",e),e}}(a,t,e));e.accounts[n].signature=r}}function St(e){return{script:e.message.cadence,refBlock:e.message.refBlock||null,gasLimit:e.message.computeLimit,arguments:e.message.arguments.map(t=>e.arguments[t].asArgument),proposalKey:{address:y(e.accounts[e.proposer].addr),keyId:e.accounts[e.proposer].keyId,sequenceNum:e.accounts[e.proposer].sequenceNum},payer:y(e.accounts[e.payer].addr),authorizers:e.authorizations.map(t=>y(e.accounts[t].addr)).reduce((e,t)=>e.find(e=>e===t)?e:[...e,t],[])}}async function vt(e){const t=me(e,"ix.validators",[]);return pe(e,t.map(e=>t=>e(t,{Ok:_,Bad:O})))}const Bt=pe([$e,Me,Qe,async function(e){return Q(e)&&null==e.message.refBlock&&(e.message.refBlock=(await Oe(Ie([Ue()])).then(ze)).id),e},async function(e){if(Q(e)){var n=Object.values(e.accounts).find(e=>e.role.proposer);t(n,"Transactions require a proposer"),null==n.sequenceNum&&(e.accounts[n.tempId].sequenceNum=await Oe(await Ie([Ce(n.addr)])).then(ze).then(e=>e.keys).then(e=>e.find(e=>e.index===n.keyId)).then(e=>e.sequenceNumber))}return e},wt,async function(e){for(let t of Object.keys(e.accounts))e.accounts[t].addr=y(e.accounts[t].addr);return e},vt]),At=async(t=[],n={})=>{const a=await e().get("sdk.send",n.send||Oe),r=await e().get("sdk.resolve",n.resolve||Bt);return Array.isArray(t)&&(t=pe(x(),t)),a(await r(t),n)};async function xt(t){const n=await e().where(/^decoder\./),a=Object.entries(n).map(([e,t])=>[e=`/${e.replace(/^decoder\./,"")}$/`,t]);return ze(t,Object.fromEntries(a))}function Tt(...e){let t=e[1]||("object"==typeof e[0]?e[0]:void 0),n="boolean"==typeof e[0]?e[0]:void 0;return"object"==typeof e[0]&&console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing options as the first arguement to the latestBlock function has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0007-deprecate-opts-first-arg-latest-block\n  \n      ============================\n    ","font-weight:bold;font-family:monospace;"),At([Ue(n)],t).then(ze)}function Nt(e,t){return At([Ce(e)],t).then(ze)}const Et={authorizer:!0};function Lt(e=[]){return pe(e.map(e=>{return t="function"==typeof e?{resolve:e,role:Et,roles:Et}:v({},e,{role:Et,roles:Et}),e=>{let n=L();return e.authorizations.push(n),_(pe(e,[C(t,n)]))};var t}))}function _t(e,t,n,a){return{addr:e,signingFunction:t,keyId:n,sequenceNum:a}}function Ot(e){return ye("ix.validators",t=>Array.isArray(t)?t.push(e):[e])}function Ut(e){return pe([t=>(t.block.height=e,_(t)),Ot((e,{Ok:t,Bad:n})=>"boolean"==typeof e.block.isSealed?n(e,"Unable to specify both block height and isSealed."):e.block.id?n(e,"Unable to specify both block height and block id."):t(e))])}function Ct(e){return pe([t=>(t.block.id=e,_(t)),Ot((e,{Ok:t,Bad:n})=>te(e)?n(e,"Unable to specify a block id with a Get Account interaction."):"boolean"==typeof e.block.isSealed?n(e,"Unable to specify both block id and isSealed."):e.block.height?n(e,"Unable to specify both block id and block height."):t(e))])}function Rt(e,t,n){return void 0===t&&void 0===n||console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing a start and end into getEnvents has been deprecated and will not be supported in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder\n  \n      ============================\n    ","font-weight:bold;font-family:monospace;"),pe([z,a=>(a.events.eventType=e,a.events.start=t,a.events.end=n,_(a))])}function Dt(e,t,n){return pe([z,a=>(a.events.eventType=e,a.events.start=t,a.events.end=n,_(a))])}function Gt(e,t=[]){return pe([z,n=>(n.events.eventType=e,n.events.blockIds=t,_(n))])}function Kt(e=null){return pe([Y,t=>(t.block.isSealed=e,_(t))])}function Pt(e=!1){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getLatestBlock builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0006-deprecate-get-latest-block-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),pe([F,t=>(t.block.isSealed=e,_(t))])}function jt(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockById builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0004-deprecate-get-block-by-id-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),pe([q,t=>(t.block.ids=[e],_(t))])}function Ht(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockByHeight builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0003-deprecate-get-block-by-height-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),pe([J,t=>(t.block.height=e,_(t))])}function zt(e){return pe([P,t=>(t.transaction.id=e,_(t))])}function Ft(e){return pe([j,t=>(t.transaction.id=e,_(t))])}function qt(e){return pe([t=>(t.message.computeLimit=e,_(t))])}function Jt(e=[]){return pe(e.map(R))}function $t(e,t=null,n=null){return{key:n,value:e,xform:null}}function Wt(e=[]){return pe(e.map(D))}function Yt(e,t){return{value:e,xform:t}}const Mt={proposer:!0};async function Vt(e){return t="function"==typeof e?{resolve:e,role:Mt,roles:Mt}:v({},e,{role:Mt,roles:Mt}),e=>{let n=L();return e.proposer=n,_(pe(e,[C(t,n)]))};var t}const Xt={payer:!0};function Qt(e){return t="function"==typeof e?{resolve:e,role:Xt,roles:Xt}:v({},e,{role:Xt,roles:Xt}),e=>{let n=L();return e.payer=n,_(pe(e,[C(t,n)]))};var t}function Zt(){return $}function en(e){return pe([t=>(t.message.refBlock=e,_(t))])}function tn(...e){return pe([G,he("ix.cadence",S(...e))])}const nn=[];function an(...e){return pe([K,he("ix.cadence",S(...e)),e=>(e.message.computeLimit=e.message.computeLimit||10,e.message.refBlock=e.message.refBlock||null,e.authorizations=e.authorizations||nn,_(e))])}function rn(...e){if(e.length>1){const[t,n]=e;return rn((e,{Ok:a,Bad:r})=>t?a(e):r(e,n))}const[t]=e;return e=>t(e,{Ok:_,Bad:O})}function on(e){return console.error("\n      %cFCL/SDK Deprecation Notice\n      ============================\n\n      The resolver sdk.resolveParams is being replaced with the package @onflow/sdk-resolve-cadence\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0002-deprecate-resolve-params-resolver\n\n      ============================\n    ","font-weight:bold;font-family:monospace;"),$e(e)}export{Nt as account,Yt as arg,Wt as args,Ut as atBlockHeight,Ct as atBlockId,_t as authorization,Lt as authorizations,Ie as build,xt as decode,ke as destroy,me as get,Ce as getAccount,Ue as getBlock,Ht as getBlockByHeight,jt as getBlockById,Kt as getBlockHeader,Rt as getEvents,Dt as getEventsAtBlockHeightRange,Gt as getEventsAtBlockIds,Pt as getLatestBlock,Ft as getTransaction,zt as getTransactionStatus,x as interaction,rn as invariant,le as isBad,te as isGetAccount,ce as isGetBlock,oe as isGetBlockByHeight,re as isGetBlockById,ie as isGetBlockHeader,ne as isGetEvents,ae as isGetLatestBlock,ee as isGetTransaction,Z as isGetTransactionStatus,ue as isOk,se as isPing,X as isScript,Q as isTransaction,V as isUnknown,Tt as latestBlock,qt as limit,$t as param,Jt as params,Qt as payer,Zt as ping,pe as pipe,Vt as proposer,he as put,en as ref,Bt as resolve,Qe as resolveAccounts,Me as resolveArguments,on as resolveParams,Fe as resolveRefBlockId,wt as resolveSignatures,vt as resolveValidators,tn as script,At as send,an as transaction,ye as update,Ot as validator,de as why};
//# sourceMappingURL=sdk.modern.js.map
